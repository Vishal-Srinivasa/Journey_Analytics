1) Detailed report on execution of project
Purpose: Build a Geminiâ†”Neon MCP bridge with a Streamlit chat UI that can query Neon DB multiple times and retain memory.
Core components:
Backend agent: GeminiNeonBridge manages MCP session, tool calls, and iterative reasoning.
Frontend: streamlit_app.py provides chat UI, displays SQL, and renders tool outputs.
Containerization: Dockerfile builds a runnable image; .env provides keys.
Execution flow:
User submits a query in Streamlit.
App sends prompt to Gemini with MCP tools enabled.
Model decides on tool calls (e.g., run_sql) and executes iteratively.
SQL + result are returned and rendered; chat memory persists.
Run locally:
pip install -r requirements.txt
streamlit run streamlit_app.py
Run in Docker:
docker build -t journey_analytics .
docker run --env-file .env -p 8501:8501 journey_analytics
2) Detailed deployment plan
Container build:
Build image with pinned dependencies and Streamlit entrypoint.
Secrets management:
Use .env for NEON_API_KEY, NEON_PROJECT_ID, GEMINI_API_KEY.
For production, replace with secret manager (e.g., AWS Secrets Manager, GCP Secret Manager).
Runtime:
Deploy on a container platform (Docker, Kubernetes, ECS, Cloud Run).
Expose port 8501 (or map to another).
Observability:
Add structured logging for tool calls and errors.
Health checks for Streamlit endpoint.
Scaling:
Horizontal scaling with stateless Streamlit containers.
Optional external session store (Redis) to preserve chat memory across instances.
CI/CD:
Add GitHub Actions to lint, test, build, and publish images.
Tag images per commit.
3) Area of focus of project
Scalability:
Stateless UI; can scale horizontally.
MCP and Gemini calls are externalized; optional queueing if needed.
Maintainability:
Clear separation between UI and tool execution.
Centralized tool normalization and MCP handling.
Reliability:
Retries and error handling on MCP calls.
Iterative tool usage to ensure accurate responses.
4) Future work (next steps/enhancements)
Session persistence: Store chat history in DB/Redis for multi-user sessions.
Role-based access: Limit which queries or tables can be accessed.
Caching: Cache frequent SQL results to reduce latency.
Schema discovery UI: Visualize tables/columns for easier querying.
Improved reasoning control: Tool-call budget controls, guardrails for query safety.
Testing: Add unit/integration tests for MCP calls and Streamlit UI.